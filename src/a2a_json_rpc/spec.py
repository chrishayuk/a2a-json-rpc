# generated by datamodel-codegen (modified)
# filename: a2a_spec_fixed.py

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Annotated, Any, Dict, List, Literal, Union, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, model_validator


# ---------------------------
# Core enums / simple types
# ---------------------------

class Role(Enum):
    user = 'user'
    agent = 'agent'


class TransportProtocol(str, Enum):
    JSONRPC = 'JSONRPC'
    GRPC = 'GRPC'
    HTTP_JSON = 'HTTP+JSON'


class TaskState(Enum):
    """
    Task state enumeration according to A2A Protocol specification.
    """

    submitted = 'submitted'
    working = 'working'
    input_required = 'input-required'
    completed = 'completed'
    canceled = 'canceled'
    failed = 'failed'
    rejected = 'rejected'
    auth_required = 'auth-required'
    unknown = 'unknown'


# ---------------------------
# JSON-RPC base types & errors
# ---------------------------

class JSONRPCError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[int, Field(title='Code')]
    message: Annotated[str, Field(title='Message')]
    data: Annotated[Any | None, Field(title='Data')] = None


class JSONRPCMessage(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None


class JSONRPCRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    method: Annotated[str, Field(title='Method')]
    params: Annotated[Any | None, Field(title='Params')] = None


class JSONRPCResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    result: Annotated[Any | None, Field(title='Result')] = None
    error: Annotated[JSONRPCError | None, Field(title='Error')] = None


# Standard JSON-RPC errors shaped per spec
class JSONParseError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32700], Field(examples=[-32700], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Invalid JSON payload'],
        Field(examples=['Invalid JSON payload'], title='Message'),
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')] = None


class InvalidRequestError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32600], Field(examples=[-32600], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Request payload validation error'],
        Field(examples=['Request payload validation error'], title='Message'),
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')] = None


class MethodNotFoundError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32601], Field(examples=[-32601], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Method not found'],
        Field(examples=['Method not found'], title='Message'),
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')] = None


class InvalidParamsError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32602], Field(examples=[-32602], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Invalid parameters'],
        Field(examples=['Invalid parameters'], title='Message'),
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')] = None


class InternalError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32603], Field(examples=[-32603], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Internal error'], Field(examples=['Internal error'], title='Message')
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')] = None


# ---------------------------
# Part / File models
# ---------------------------

class TextPart(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['text'], Field(examples=['text'], title='Type')]
    """
    Type of the part
    """
    text: Annotated[str, Field(title='Text')]
    metadata: Annotated[Any | None, Field(title='Metadata')] = None


class FileWithBytes(BaseModel):
    """
    File variant carrying inline bytes (base64-encoded or raw bytes representation).
    Matches spec's 'file-with-bytes' variant.
    """
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Annotated[Any | None, Field(title='Name')] = None
    mime_type: Annotated[Any | None, Field(alias='mimeType', title='Mimetype')] = None
    bytes: Annotated[Any, Field(title='Bytes')]
    uri: Annotated[Any | None, Field(title='Uri')] = None

    @model_validator(mode='after')
    def _ensure_bytes_present(cls) -> 'FileWithBytes':
        # If this variant is chosen, bytes MUST be present.
        if getattr(cls, 'bytes', None) is None:
            raise ValueError('FileWithBytes requires "bytes" to be present')
        # And uri should not be used in this variant (prefer explicit FileWithUri)
        if getattr(cls, 'uri', None) is not None:
            raise ValueError('FileWithBytes must not include "uri"')
        return cls


class FileWithUri(BaseModel):
    """
    File variant referencing a URI. Matches spec's 'file-with-uri' variant.
    """
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: Annotated[Any | None, Field(title='Name')] = None
    mime_type: Annotated[Any | None, Field(alias='mimeType', title='Mimetype')] = None
    bytes: Annotated[Any | None, Field(title='Bytes')] = None
    uri: Annotated[str, Field(title='Uri')]

    @model_validator(mode='after')
    def _ensure_uri_present(cls) -> 'FileWithUri':
        if getattr(cls, 'uri', None) in (None, ''):
            raise ValueError('FileWithUri requires a non-empty "uri"')
        # bytes must not be present in this variant
        if getattr(cls, 'bytes', None) is not None:
            raise ValueError('FileWithUri must not include "bytes"')
        return cls


class FilePart(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['file'], Field(examples=['file'], title='Type')]
    """
    Type of the part
    """
    file: Annotated[Union[FileWithBytes, FileWithUri], Field(title='File')]
    metadata: Annotated[Any | None, Field(title='Metadata')] = None


class DataPart(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['data'], Field(examples=['data'], title='Type')]
    """
    Type of the part
    """
    data: Annotated[Dict[str, Any], Field(title='Data')]
    metadata: Annotated[Any | None, Field(title='Metadata')] = None


# Part is a strict union of concrete parts
Part = Union[TextPart, FilePart, DataPart]


# ---------------------------
# Message / Artifact / Task models
# ---------------------------

class Message(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    role: Annotated[Role, Field(title='Role')]
    parts: Annotated[List[Part], Field(title='Parts')]
    metadata: Annotated[Any | None, Field(title='Metadata')] = None
    extensions: Annotated[List[str] | None, Field(title='Extensions')] = None
    reference_task_ids: Annotated[List[str] | None, Field(alias='referenceTaskIds', title='Referencetaskids')] = None
    message_id: Annotated[str, Field(alias='messageId', title='Messageid')]
    task_id: Annotated[str | None, Field(alias='taskId', title='Taskid')] = None
    context_id: Annotated[str | None, Field(alias='contextId', title='Contextid')] = None
    kind: Annotated[Literal['message'], Field(title='Kind')] = 'message'


class Artifact(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    artifact_id: Annotated[str, Field(alias='artifactId', title='Artifactid')]
    name: Annotated[Any | None, Field(title='Name')] = None
    description: Annotated[Any | None, Field(title='Description')] = None
    parts: Annotated[List[Part], Field(title='Parts')]
    metadata: Annotated[Any | None, Field(title='Metadata')] = None
    extensions: Annotated[List[str] | None, Field(title='Extensions')] = None


class TaskStatus(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    state: TaskState
    message: Annotated[Message | None, Field(title='Message')] = None
    timestamp: Annotated[datetime | None, Field(title='Timestamp')] = None


class Task(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[str, Field(title='Id')]
    # contextId groups related tasks; keep sessionId for backward compatibility
    context_id: Annotated[str | None, Field(alias='contextId', title='Contextid')] = None
    session_id: Annotated[Any | None, Field(alias='sessionId', title='Sessionid')] = None
    status: TaskStatus
    artifacts: Annotated[List[Artifact] | None, Field(title='Artifacts')] = None
    history: Annotated[List[Message] | None, Field(title='History')] = None
    metadata: Annotated[Dict[str, Any] | None, Field(title='Metadata')] = None
    kind: Annotated[Literal['task'], Field(title='Kind')] = 'task'


# ---------------------------
# Task RPC params / requests / responses
# ---------------------------

class TaskIdParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[str, Field(title='Id')]
    metadata: Annotated[Any | None, Field(title='Metadata')] = None


class TaskQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[str, Field(title='Id')]
    history_length: Annotated[Any | None, Field(alias='historyLength', title='HistoryLength')] = None
    metadata: Annotated[Any | None, Field(title='Metadata')] = None


class TaskSendParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[str, Field(title='Id')]
    session_id: Annotated[str, Field(alias='sessionId', title='Sessionid')]
    message: Message
    push_notification: Annotated[Any | None, Field(alias='pushNotification')] = None
    history_length: Annotated[Any | None, Field(alias='historyLength', title='HistoryLength')] = None
    metadata: Annotated[Any | None, Field(alias='Metadata')] = None


# RPC request classes
class SendTaskRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    method: Annotated[Literal['tasks/send'], Field(title='Method')]
    params: TaskSendParams


class SendTaskStreamingRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    method: Annotated[Literal['tasks/sendSubscribe'], Field(title='Method')]
    params: TaskSendParams


class GetTaskRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    method: Annotated[Literal['tasks/get'], Field(title='Method')]
    params: TaskQueryParams


class CancelTaskRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    method: Annotated[Literal['tasks/cancel'], Field(title='Method')]
    params: TaskIdParams


class GetTaskPushNotificationRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    method: Annotated[Literal['tasks/pushNotification/get'], Field(title='Method')]
    params: TaskIdParams


class SetTaskPushNotificationRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    method: Annotated[Literal['tasks/pushNotification/set'], Field(title='Method')]
    params: 'TaskPushNotificationConfig'


# RPC response classes (fixed result/error typing)
class SendTaskResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    result: Annotated[Any | None, Field(title='Result')] = None
    error: Annotated[JSONRPCError | None, Field(title='Error')] = None


class SendTaskStreamingResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    result: Annotated[Any | None, Field(title='Result')] = None
    error: Annotated[JSONRPCError | None, Field(title='Error')] = None


class GetTaskResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    result: Annotated[Any | None, Field(title='Result')] = None
    error: Annotated[JSONRPCError | None, Field(title='Error')] = None


class GetTaskPushNotificationResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    result: Annotated[Any | None, Field(title='Result')] = None
    error: Annotated[JSONRPCError | None, Field(title='Error')] = None


class CancelTaskResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    result: Annotated[Any | None, Field(title='Result')] = None
    error: Annotated[JSONRPCError | None, Field(title='Error')] = None


class SetTaskPushNotificationResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    jsonrpc: Annotated[Literal['2.0'], Field(title='Jsonrpc')] = '2.0'
    id: Annotated[Any | None, Field(title='Id')] = None
    result: Annotated[Any | None, Field(title='Result')] = None
    error: Annotated[JSONRPCError | None, Field(title='Error')] = None


# ---------------------------
# Push notifications, auth, misc errors
# ---------------------------

class AuthenticationInfo(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    schemes: Annotated[List[str], Field(title='Schemes')]
    credentials: Annotated[Any | None, Field(title='Credentials')] = None


# Backwards/alternate name used in TypeScript spec
PushNotificationAuthenticationInfo = AuthenticationInfo


class PushNotificationNotSupportedError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32003], Field(examples=[-32003], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Push Notification is not supported'],
        Field(examples=['Push Notification is not supported'], title='Message'),
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')]


class TaskNotFoundError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32001], Field(examples=[-32001], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Task not found'], Field(examples=['Task not found'], title='Message')
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')]


class TaskNotCancelableError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32002], Field(examples=[-32002], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['Task cannot be canceled'],
        Field(examples=['Task cannot be canceled'], title='Message'),
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')]


class UnsupportedOperationError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[Literal[-32004], Field(examples=[-32004], title='Code')]
    """
    Error code
    """
    message: Annotated[
        Literal['This operation is not supported'],
        Field(examples=['This operation is not supported'], title='Message'),
    ]
    """
    A short description of the error
    """
    data: Annotated[Any | None, Field(title='Data')]


# ---------------------------
# Agent / AgentCard / capabilities / security schemes
# ---------------------------

class AgentAuthentication(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    schemes: Annotated[List[str], Field(title='Schemes')]
    credentials: Annotated[Any | None, Field(title='Credentials')] = None


class AgentExtension(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    uri: Annotated[str, Field(title='Uri')]
    description: Annotated[str | None, Field(title='Description')] = None
    required: Annotated[bool | None, Field(title='Required')] = False
    params: Annotated[Dict[str, Any] | None, Field(title='Params')] = None


class AgentCapabilities(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    streaming: Annotated[bool | None, Field(title='Streaming')] = False
    push_notifications: Annotated[
        bool | None, Field(alias='pushNotifications', title='PushNotifications')
    ] = False
    state_transition_history: Annotated[
        bool | None,
        Field(alias='stateTransitionHistory', title='Statetransitionhistory'),
    ] = False
    extensions: Annotated[
        List[AgentExtension] | None, Field(title='Extensions')
    ] = None


class AgentProvider(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    organization: Annotated[str, Field(title='Organization')]
    url: Annotated[Any | None, Field(title='Url')] = None


class AgentSkill(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[str, Field(title='Id')]
    name: Annotated[str, Field(title='Name')]
    description: Annotated[str, Field(title='Description')]
    tags: Annotated[List[str], Field(title='Tags')]
    examples: Annotated[List[str] | None, Field(title='Examples')] = None
    input_modes: Annotated[List[str] | None, Field(alias='inputModes', title='Inputmodes')] = None
    output_modes: Annotated[List[str] | None, Field(alias='outputModes', title='Outputmodes')] = None
    security: Annotated[List[Dict[str, List[str]]] | None, Field(title='Security')] = None


class AgentCardSignature(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protected: Annotated[str, Field(title='Protected')]  # base64url-encoded JSON header
    signature: Annotated[str, Field(title='Signature')]
    header: Annotated[Dict[str, Any] | None, Field(title='Header')] = None


# Security scheme models (OpenAPI-like)
class APIKeySecurityScheme(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['apiKey'], Field(title='Type')] = 'apiKey'
    name: Annotated[str, Field(title='Name')]
    in_: Annotated[str, Field(alias='in', title='In')]
    description: Annotated[Any | None, Field(title='Description')] = None


class HTTPAuthSecurityScheme(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['http'], Field(title='Type')] = 'http'
    scheme: Annotated[str, Field(title='Scheme')]
    bearer_format: Annotated[Any | None, Field(alias='bearerFormat', title='Bearerformat')] = None
    description: Annotated[Any | None, Field(title='Description')] = None


class OAuth2SecurityScheme(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['oauth2'], Field(title='Type')] = 'oauth2'
    flows: Annotated[Dict[str, Any], Field(title='Flows')]
    description: Annotated[Any | None, Field(title='Description')] = None


class OpenIdConnectSecurityScheme(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['openIdConnect'], Field(title='Type')] = 'openIdConnect'
    open_id_connect_url: Annotated[str, Field(alias='openIdConnectUrl', title='Openidconnecturl')]
    description: Annotated[Any | None, Field(title='Description')] = None


class MutualTLSSecurityScheme(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Annotated[Literal['mutualTLS'], Field(title='Type')] = 'mutualTLS'
    description: Annotated[Any | None, Field(title='Description')] = None


# Union type alias for all supported security schemes
SecurityScheme = Union[
    APIKeySecurityScheme,
    HTTPAuthSecurityScheme,
    OAuth2SecurityScheme,
    OpenIdConnectSecurityScheme,
    MutualTLSSecurityScheme,
]


class PushNotificationConfig(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    url: Annotated[str, Field(title='Url')]
    token: Annotated[Any | None, Field(title='Token')] = None
    authentication: Annotated[AuthenticationInfo | None, Field(title='Authentication')] = None


class TaskPushNotificationConfig(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[str, Field(title='Id')]
    push_notification_config: Annotated[
        PushNotificationConfig, Field(alias='pushNotificationConfig')
    ]

    @property
    def pushNotificationConfig(self) -> PushNotificationConfig:
        """
        Provide alias-style attribute access so tests can do:
            conf.pushNotificationConfig.url
        """
        return self.push_notification_config


# ---------------------------
# AgentInterface & AgentCard
# ---------------------------

class AgentInterface(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    url: Annotated[str, Field(title='Url')]
    transport: Annotated[TransportProtocol | str, Field(title='Transport')]


class AgentCard(BaseModel):
    """A self-describing manifest for an agent."""
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protocol_version: Annotated[str, Field(alias='protocolVersion')] = '0.3.0'
    name: Annotated[str, Field(title='Name')]
    description: Annotated[str | None, Field(title='Description')] = None
    url: Annotated[str, Field(title='Url')]
    preferred_transport: Annotated[TransportProtocol | str | None, Field(alias='preferredTransport')] = TransportProtocol.JSONRPC
    additional_interfaces: Annotated[List[AgentInterface] | None, Field(alias='additionalInterfaces')] = None
    icon_url: Annotated[str | None, Field(alias='iconUrl')] = None
    provider: Annotated[AgentProvider | None, Field(title='Provider')] = None
    version: Annotated[str, Field(title='Version')]
    documentation_url: Annotated[str | None, Field(alias='documentationUrl')] = None
    capabilities: AgentCapabilities
    authentication: Annotated[AgentAuthentication | None, Field(title='Authentication')] = None
    security_schemes: Annotated[Dict[str, SecurityScheme] | None, Field(alias='securitySchemes')] = None
    security: Annotated[List[Dict[str, List[str]]] | None, Field(title='Security')] = None
    default_input_modes: Annotated[List[str], Field(alias='defaultInputModes')] = ['text']
    default_output_modes: Annotated[List[str], Field(alias='defaultOutputModes')] = ['text']
    skills: Annotated[List[AgentSkill], Field(title='Skills')]
    supports_authenticated_extended_card: Annotated[bool, Field(alias='supportsAuthenticatedExtendedCard')] = False
    signatures: Annotated[List[AgentCardSignature] | None, Field(title='Signatures')] = None

    @model_validator(mode='after')
    def _validate_transport_relationships(self) -> 'AgentCard':
        """Enforce transport / URL relationship rules described in the spec.

        - preferredTransport MUST be present
        - if additionalInterfaces includes the main url, at least one of those
          entries MUST declare the preferredTransport for that url
        - ensure there are no duplicate (url, transport) declarations
        """
        # preferredTransport required
        if self.preferred_transport is None:
            raise ValueError('preferredTransport is required')

        # Normalize preferred for comparison
        pref = str(self.preferred_transport)

        # additional_interfaces uniqueness and main-url consistency
        if self.additional_interfaces:
            seen = set()
            main_url_entries = []
            for iface in self.additional_interfaces:
                key = (iface.url, str(iface.transport))
                if key in seen:
                    raise ValueError(f'Duplicate interface declaration for url={iface.url} transport={iface.transport}')
                seen.add(key)
                if iface.url == self.url:
                    main_url_entries.append(iface)

            # If additionalInterfaces contains entries for the main url, one must match preferredTransport
            if main_url_entries:
                if not any(str(iface.transport) == pref for iface in main_url_entries):
                    raise ValueError('Additional interfaces include the main url but none match preferredTransport')

        # At least one transport must be declared (preferredTransport covers that requirement)
        return self


# ---------------------------
# Root / miscellaneous
# ---------------------------

class A2AProtocolSchema(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[Any, Field(title='A2A Protocol Schema')]
    """
    JSON Schema for A2A Protocol
    """


class A2ARequest(RootModel[None]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Annotated[Any | None, Field(title='A2ARequest')]

