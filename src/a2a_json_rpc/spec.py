# generated by datamodel-codegen:
#   filename:  a2a_spec.json
#   timestamp: 2025-09-15T14:36:57+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class In(Enum):
    cookie = 'cookie'
    header = 'header'
    query = 'query'


class APIKeySecurityScheme(BaseModel):
    description: Optional[str] = Field(
        None, description='An optional description for the security scheme.'
    )
    in_: In = Field(..., alias='in', description='The location of the API key.')
    name: str = Field(
        ...,
        description='The name of the header, query, or cookie parameter to be used.',
    )
    type: Literal['apiKey'] = Field(
        ..., description="The type of the security scheme. Must be 'apiKey'."
    )


class AgentCardSignature(BaseModel):
    header: Optional[Dict[str, Any]] = Field(
        None, description='The unprotected JWS header values.'
    )
    protected: str = Field(
        ...,
        description='The protected JWS header for the signature. This is a Base64url-encoded\nJSON object, as per RFC 7515.',
    )
    signature: str = Field(
        ..., description='The computed signature, Base64url-encoded.'
    )


class AgentExtension(BaseModel):
    description: Optional[str] = Field(
        None,
        description='A human-readable description of how this agent uses the extension.',
    )
    params: Optional[Dict[str, Any]] = Field(
        None, description='Optional, extension-specific configuration parameters.'
    )
    required: Optional[bool] = Field(
        None,
        description="If true, the client must understand and comply with the extension's requirements\nto interact with the agent.",
    )
    uri: str = Field(..., description='The unique URI identifying the extension.')


class AgentInterface(BaseModel):
    transport: str = Field(
        ...,
        description='The transport protocol supported at this URL.',
        examples=['JSONRPC', 'GRPC', 'HTTP+JSON'],
    )
    url: str = Field(
        ...,
        description='The URL where this interface is available. Must be a valid absolute HTTPS URL in production.',
        examples=[
            'https://api.example.com/a2a/v1',
            'https://grpc.example.com/a2a',
            'https://rest.example.com/v1',
        ],
    )


class AgentProvider(BaseModel):
    organization: str = Field(
        ..., description="The name of the agent provider's organization."
    )
    url: str = Field(
        ...,
        description="A URL for the agent provider's website or relevant documentation.",
    )


class AgentSkill(BaseModel):
    description: str = Field(
        ...,
        description='A detailed description of the skill, intended to help clients or users\nunderstand its purpose and functionality.',
    )
    examples: Optional[List[str]] = Field(
        None,
        description='Example prompts or scenarios that this skill can handle. Provides a hint to\nthe client on how to use the skill.',
        examples=[['I need a recipe for bread']],
    )
    id: str = Field(..., description="A unique identifier for the agent's skill.")
    inputModes: Optional[List[str]] = Field(
        None,
        description="The set of supported input MIME types for this skill, overriding the agent's defaults.",
    )
    name: str = Field(..., description='A human-readable name for the skill.')
    outputModes: Optional[List[str]] = Field(
        None,
        description="The set of supported output MIME types for this skill, overriding the agent's defaults.",
    )
    security: Optional[List[Dict[str, List[str]]]] = Field(
        None,
        description='Security schemes necessary for the agent to leverage this skill.\nAs in the overall AgentCard.security, this list represents a logical OR of security\nrequirement objects. Each object is a set of security schemes that must be used together\n(a logical AND).',
        examples=[[{'google': ['oidc']}]],
    )
    tags: List[str] = Field(
        ...,
        description="A set of keywords describing the skill's capabilities.",
        examples=[['cooking', 'customer support', 'billing']],
    )


class AuthenticatedExtendedCardNotConfiguredError(BaseModel):
    code: Literal[-32007] = Field(
        ...,
        description='The error code for when an authenticated extended card is not configured.',
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class AuthorizationCodeOAuthFlow(BaseModel):
    authorizationUrl: str = Field(
        ...,
        description='The authorization URL to be used for this flow.\nThis MUST be a URL and use TLS.',
    )
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens.\nThis MUST be a URL and use TLS.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.',
    )
    tokenUrl: str = Field(
        ...,
        description='The token URL to be used for this flow.\nThis MUST be a URL and use TLS.',
    )


class ClientCredentialsOAuthFlow(BaseModel):
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens. This MUST be a URL.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.',
    )
    tokenUrl: str = Field(
        ..., description='The token URL to be used for this flow. This MUST be a URL.'
    )


class ContentTypeNotSupportedError(BaseModel):
    code: Literal[-32005] = Field(
        ..., description='The error code for an unsupported content type.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class DataPart(BaseModel):
    data: Dict[str, Any] = Field(..., description='The structured data content.')
    kind: Literal['data'] = Field(
        ...,
        description="The type of this part, used as a discriminator. Always 'data'.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with this part.'
    )


class DeleteTaskPushNotificationConfigParams(BaseModel):
    id: str = Field(..., description='The unique identifier (e.g. UUID) of the task.')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the request.'
    )
    pushNotificationConfigId: str = Field(
        ..., description='The ID of the push notification configuration to delete.'
    )


class DeleteTaskPushNotificationConfigRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['tasks/pushNotificationConfig/delete'] = Field(
        ...,
        description="The method name. Must be 'tasks/pushNotificationConfig/delete'.",
    )
    params: DeleteTaskPushNotificationConfigParams = Field(
        ...,
        description='The parameters identifying the push notification configuration to delete.',
    )


class DeleteTaskPushNotificationConfigSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: None = Field(..., description='The result is null on successful deletion.')


class FileBase(BaseModel):
    mimeType: Optional[str] = Field(
        None, description='The MIME type of the file (e.g., "application/pdf").'
    )
    name: Optional[str] = Field(
        None, description='An optional name for the file (e.g., "document.pdf").'
    )


class FileWithBytes(BaseModel):
    bytes: str = Field(..., description='The base64-encoded content of the file.')
    mimeType: Optional[str] = Field(
        None, description='The MIME type of the file (e.g., "application/pdf").'
    )
    name: Optional[str] = Field(
        None, description='An optional name for the file (e.g., "document.pdf").'
    )


class FileWithUri(BaseModel):
    mimeType: Optional[str] = Field(
        None, description='The MIME type of the file (e.g., "application/pdf").'
    )
    name: Optional[str] = Field(
        None, description='An optional name for the file (e.g., "document.pdf").'
    )
    uri: str = Field(..., description="A URL pointing to the file's content.")


class GetAuthenticatedExtendedCardRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['agent/getAuthenticatedExtendedCard'] = Field(
        ...,
        description="The method name. Must be 'agent/getAuthenticatedExtendedCard'.",
    )


class GetTaskPushNotificationConfigParams(BaseModel):
    id: str = Field(..., description='The unique identifier (e.g. UUID) of the task.')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the request.'
    )
    pushNotificationConfigId: Optional[str] = Field(
        None, description='The ID of the push notification configuration to retrieve.'
    )


class HTTPAuthSecurityScheme(BaseModel):
    bearerFormat: Optional[str] = Field(
        None,
        description='A hint to the client to identify how the bearer token is formatted (e.g., "JWT").\nThis is primarily for documentation purposes.',
    )
    description: Optional[str] = Field(
        None, description='An optional description for the security scheme.'
    )
    scheme: str = Field(
        ...,
        description='The name of the HTTP Authentication scheme to be used in the Authorization header,\nas defined in RFC7235 (e.g., "Bearer").\nThis value should be registered in the IANA Authentication Scheme registry.',
    )
    type: Literal['http'] = Field(
        ..., description="The type of the security scheme. Must be 'http'."
    )


class ImplicitOAuthFlow(BaseModel):
    authorizationUrl: str = Field(
        ...,
        description='The authorization URL to be used for this flow. This MUST be a URL.',
    )
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens. This MUST be a URL.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.',
    )


class InternalError(BaseModel):
    code: Literal[-32603] = Field(
        ..., description='The error code for an internal server error.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class InvalidAgentResponseError(BaseModel):
    code: Literal[-32006] = Field(
        ..., description='The error code for an invalid agent response.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class InvalidParamsError(BaseModel):
    code: Literal[-32602] = Field(
        ..., description='The error code for an invalid parameters error.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class InvalidRequestError(BaseModel):
    code: Literal[-32600] = Field(
        ..., description='The error code for an invalid request.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class JSONParseError(BaseModel):
    code: Literal[-32700] = Field(
        ..., description='The error code for a JSON parse error.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class JSONRPCError(BaseModel):
    code: int = Field(
        ..., description='A number that indicates the error type that occurred.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(
        ..., description='A string providing a short description of the error.'
    )


class JSONRPCMessage(BaseModel):
    id: Optional[Union[str, int]] = Field(
        None,
        description='A unique identifier established by the client. It must be a String, a Number, or null.\nThe server must reply with the same value in the response. This property is omitted for notifications.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )


class JSONRPCRequest(BaseModel):
    id: Optional[Union[str, int]] = Field(
        None,
        description='A unique identifier established by the client. It must be a String, a Number, or null.\nThe server must reply with the same value in the response. This property is omitted for notifications.',
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: str = Field(
        ..., description='A string containing the name of the method to be invoked.'
    )
    params: Optional[Dict[str, Any]] = Field(
        None,
        description='A structured value holding the parameter values to be used during the method invocation.',
    )


class JSONRPCSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: Any = Field(
        ...,
        description='The value of this member is determined by the method invoked on the Server.',
    )


class ListTaskPushNotificationConfigParams(BaseModel):
    id: str = Field(..., description='The unique identifier (e.g. UUID) of the task.')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the request.'
    )


class ListTaskPushNotificationConfigRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['tasks/pushNotificationConfig/list'] = Field(
        ..., description="The method name. Must be 'tasks/pushNotificationConfig/list'."
    )
    params: ListTaskPushNotificationConfigParams = Field(
        ...,
        description='The parameters identifying the task whose configurations are to be listed.',
    )


class Role(Enum):
    agent = 'agent'
    user = 'user'


class MethodNotFoundError(BaseModel):
    code: Literal[-32601] = Field(
        ..., description='The error code for a method not found error.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class MutualTLSSecurityScheme(BaseModel):
    description: Optional[str] = Field(
        None, description='An optional description for the security scheme.'
    )
    type: Literal['mutualTLS'] = Field(
        ..., description="The type of the security scheme. Must be 'mutualTLS'."
    )


class OpenIdConnectSecurityScheme(BaseModel):
    description: Optional[str] = Field(
        None, description='An optional description for the security scheme.'
    )
    openIdConnectUrl: str = Field(
        ...,
        description="The OpenID Connect Discovery URL for the OIDC provider's metadata.",
    )
    type: Literal['openIdConnect'] = Field(
        ..., description="The type of the security scheme. Must be 'openIdConnect'."
    )


class PartBase(BaseModel):
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with this part.'
    )


class PasswordOAuthFlow(BaseModel):
    refreshUrl: Optional[str] = Field(
        None,
        description='The URL to be used for obtaining refresh tokens. This MUST be a URL.',
    )
    scopes: Dict[str, str] = Field(
        ...,
        description='The available scopes for the OAuth2 security scheme. A map between the scope\nname and a short description for it.',
    )
    tokenUrl: str = Field(
        ..., description='The token URL to be used for this flow. This MUST be a URL.'
    )


class PushNotificationAuthenticationInfo(BaseModel):
    credentials: Optional[str] = Field(
        None,
        description='Optional credentials required by the push notification endpoint.',
    )
    schemes: List[str] = Field(
        ...,
        description="A list of supported authentication schemes (e.g., 'Basic', 'Bearer').",
    )


class PushNotificationConfig(BaseModel):
    authentication: Optional[PushNotificationAuthenticationInfo] = Field(
        None,
        description='Optional authentication details for the agent to use when calling the notification URL.',
    )
    id: Optional[str] = Field(
        None,
        description='A unique identifier (e.g. UUID) for the push notification configuration, set by the client\nto support multiple notification callbacks.',
    )
    token: Optional[str] = Field(
        None,
        description='A unique token for this task or session to validate incoming push notifications.',
    )
    url: str = Field(
        ...,
        description='The callback URL where the agent should send push notifications.',
    )


class PushNotificationNotSupportedError(BaseModel):
    code: Literal[-32003] = Field(
        ..., description='The error code for when push notifications are not supported.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class SecuritySchemeBase(BaseModel):
    description: Optional[str] = Field(
        None, description='An optional description for the security scheme.'
    )


class TaskIdParams(BaseModel):
    id: str = Field(..., description='The unique identifier (e.g. UUID) of the task.')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the request.'
    )


class TaskNotCancelableError(BaseModel):
    code: Literal[-32002] = Field(
        ..., description='The error code for a task that cannot be canceled.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class TaskNotFoundError(BaseModel):
    code: Literal[-32001] = Field(
        ..., description='The error code for a task not found error.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class TaskPushNotificationConfig(BaseModel):
    pushNotificationConfig: PushNotificationConfig = Field(
        ..., description='The push notification configuration for this task.'
    )
    taskId: str = Field(
        ..., description='The unique identifier (e.g. UUID) of the task.'
    )


class TaskQueryParams(BaseModel):
    historyLength: Optional[int] = Field(
        None,
        description="The number of most recent messages from the task's history to retrieve.",
    )
    id: str = Field(..., description='The unique identifier (e.g. UUID) of the task.')
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with the request.'
    )


class TaskResubscriptionRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['tasks/resubscribe'] = Field(
        ..., description="The method name. Must be 'tasks/resubscribe'."
    )
    params: TaskIdParams = Field(
        ..., description='The parameters identifying the task to resubscribe to.'
    )


class TaskState(Enum):
    submitted = 'submitted'
    working = 'working'
    input_required = 'input-required'
    completed = 'completed'
    canceled = 'canceled'
    failed = 'failed'
    rejected = 'rejected'
    auth_required = 'auth-required'
    unknown = 'unknown'


class TextPart(BaseModel):
    kind: Literal['text'] = Field(
        ...,
        description="The type of this part, used as a discriminator. Always 'text'.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with this part.'
    )
    text: str = Field(..., description='The string content of the text part.')


class TransportProtocol(Enum):
    JSONRPC = 'JSONRPC'
    GRPC = 'GRPC'
    HTTP_JSON = 'HTTP+JSON'


class UnsupportedOperationError(BaseModel):
    code: Literal[-32004] = Field(
        ..., description='The error code for an unsupported operation.'
    )
    data: Optional[Any] = Field(
        None,
        description='A primitive or structured value containing additional information about the error.\nThis may be omitted.',
    )
    message: str = Field(..., description='The error message.')


class A2AError(
    RootModel[
        Union[
            JSONParseError,
            InvalidRequestError,
            MethodNotFoundError,
            InvalidParamsError,
            InternalError,
            TaskNotFoundError,
            TaskNotCancelableError,
            PushNotificationNotSupportedError,
            UnsupportedOperationError,
            ContentTypeNotSupportedError,
            InvalidAgentResponseError,
            AuthenticatedExtendedCardNotConfiguredError,
        ]
    ]
):
    root: Union[
        JSONParseError,
        InvalidRequestError,
        MethodNotFoundError,
        InvalidParamsError,
        InternalError,
        TaskNotFoundError,
        TaskNotCancelableError,
        PushNotificationNotSupportedError,
        UnsupportedOperationError,
        ContentTypeNotSupportedError,
        InvalidAgentResponseError,
        AuthenticatedExtendedCardNotConfiguredError,
    ] = Field(
        ...,
        description='A discriminated union of all standard JSON-RPC and A2A-specific error types.',
    )


class AgentCapabilities(BaseModel):
    extensions: Optional[List[AgentExtension]] = Field(
        None, description='A list of protocol extensions supported by the agent.'
    )
    pushNotifications: Optional[bool] = Field(
        None,
        description='Indicates if the agent supports sending push notifications for asynchronous task updates.',
    )
    stateTransitionHistory: Optional[bool] = Field(
        None,
        description='Indicates if the agent provides a history of state transitions for a task.',
    )
    streaming: Optional[bool] = Field(
        None,
        description='Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.',
    )


class CancelTaskRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['tasks/cancel'] = Field(
        ..., description="The method name. Must be 'tasks/cancel'."
    )
    params: TaskIdParams = Field(
        ..., description='The parameters identifying the task to cancel.'
    )


class FilePart(BaseModel):
    file: Union[FileWithBytes, FileWithUri] = Field(
        ...,
        description='The file content, represented as either a URI or as base64-encoded bytes.',
    )
    kind: Literal['file'] = Field(
        ...,
        description="The type of this part, used as a discriminator. Always 'file'.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata associated with this part.'
    )


class GetTaskPushNotificationConfigRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['tasks/pushNotificationConfig/get'] = Field(
        ..., description="The method name. Must be 'tasks/pushNotificationConfig/get'."
    )
    params: Union[TaskIdParams, GetTaskPushNotificationConfigParams] = Field(
        ..., description='The parameters for getting a push notification configuration.'
    )


class GetTaskPushNotificationConfigSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: TaskPushNotificationConfig = Field(
        ...,
        description='The result, containing the requested push notification configuration.',
    )


class GetTaskRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['tasks/get'] = Field(
        ..., description="The method name. Must be 'tasks/get'."
    )
    params: TaskQueryParams = Field(
        ..., description='The parameters for querying a task.'
    )


class JSONRPCErrorResponse(BaseModel):
    error: Union[
        JSONRPCError,
        JSONParseError,
        InvalidRequestError,
        MethodNotFoundError,
        InvalidParamsError,
        InternalError,
        TaskNotFoundError,
        TaskNotCancelableError,
        PushNotificationNotSupportedError,
        UnsupportedOperationError,
        ContentTypeNotSupportedError,
        InvalidAgentResponseError,
        AuthenticatedExtendedCardNotConfiguredError,
    ] = Field(..., description='An object describing the error that occurred.')
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )


class ListTaskPushNotificationConfigSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: List[TaskPushNotificationConfig] = Field(
        ...,
        description='The result, containing an array of all push notification configurations for the task.',
    )


class MessageSendConfiguration(BaseModel):
    acceptedOutputModes: Optional[List[str]] = Field(
        None,
        description='A list of output MIME types the client is prepared to accept in the response.',
    )
    blocking: Optional[bool] = Field(
        None,
        description='If true, the client will wait for the task to complete. The server may reject this if the task is long-running.',
    )
    historyLength: Optional[int] = Field(
        None,
        description="The number of most recent messages from the task's history to retrieve in the response.",
    )
    pushNotificationConfig: Optional[PushNotificationConfig] = Field(
        None,
        description='Configuration for the agent to send push notifications for updates after the initial response.',
    )


class OAuthFlows(BaseModel):
    authorizationCode: Optional[AuthorizationCodeOAuthFlow] = Field(
        None,
        description='Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.',
    )
    clientCredentials: Optional[ClientCredentialsOAuthFlow] = Field(
        None,
        description='Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.',
    )
    implicit: Optional[ImplicitOAuthFlow] = Field(
        None, description='Configuration for the OAuth Implicit flow.'
    )
    password: Optional[PasswordOAuthFlow] = Field(
        None, description='Configuration for the OAuth Resource Owner Password flow.'
    )


class Part(RootModel[Union[TextPart, FilePart, DataPart]]):
    root: Union[TextPart, FilePart, DataPart] = Field(
        ...,
        description='A discriminated union representing a part of a message or artifact, which can\nbe text, a file, or structured data.',
    )


class SetTaskPushNotificationConfigRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['tasks/pushNotificationConfig/set'] = Field(
        ..., description="The method name. Must be 'tasks/pushNotificationConfig/set'."
    )
    params: TaskPushNotificationConfig = Field(
        ...,
        description='The parameters for setting the push notification configuration.',
    )


class SetTaskPushNotificationConfigSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: TaskPushNotificationConfig = Field(
        ...,
        description='The result, containing the configured push notification settings.',
    )


class Artifact(BaseModel):
    artifactId: str = Field(
        ...,
        description='A unique identifier (e.g. UUID) for the artifact within the scope of the task.',
    )
    description: Optional[str] = Field(
        None, description='An optional, human-readable description of the artifact.'
    )
    extensions: Optional[List[str]] = Field(
        None, description='The URIs of extensions that are relevant to this artifact.'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Optional metadata for extensions. The key is an extension-specific identifier.',
    )
    name: Optional[str] = Field(
        None, description='An optional, human-readable name for the artifact.'
    )
    parts: List[Part] = Field(
        ..., description='An array of content parts that make up the artifact.'
    )


class DeleteTaskPushNotificationConfigResponse(
    RootModel[
        Union[JSONRPCErrorResponse, DeleteTaskPushNotificationConfigSuccessResponse]
    ]
):
    root: Union[
        JSONRPCErrorResponse, DeleteTaskPushNotificationConfigSuccessResponse
    ] = Field(
        ...,
        description='Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.',
    )


class GetTaskPushNotificationConfigResponse(
    RootModel[Union[JSONRPCErrorResponse, GetTaskPushNotificationConfigSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, GetTaskPushNotificationConfigSuccessResponse] = (
        Field(
            ...,
            description='Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get` method.',
        )
    )


class ListTaskPushNotificationConfigResponse(
    RootModel[
        Union[JSONRPCErrorResponse, ListTaskPushNotificationConfigSuccessResponse]
    ]
):
    root: Union[JSONRPCErrorResponse, ListTaskPushNotificationConfigSuccessResponse] = (
        Field(
            ...,
            description='Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list` method.',
        )
    )


class Message(BaseModel):
    contextId: Optional[str] = Field(
        None,
        description='The context ID for this message, used to group related interactions.',
    )
    extensions: Optional[List[str]] = Field(
        None, description='The URIs of extensions that are relevant to this message.'
    )
    kind: Literal['message'] = Field(
        ...,
        description="The type of this object, used as a discriminator. Always 'message' for a Message.",
    )
    messageId: str = Field(
        ...,
        description='A unique identifier for the message, typically a UUID, generated by the sender.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Optional metadata for extensions. The key is an extension-specific identifier.',
    )
    parts: List[Part] = Field(
        ...,
        description='An array of content parts that form the message body. A message can be\ncomposed of multiple parts of different types (e.g., text and files).',
    )
    referenceTaskIds: Optional[List[str]] = Field(
        None,
        description='A list of other task IDs that this message references for additional context.',
    )
    role: Role = Field(
        ...,
        description='Identifies the sender of the message. `user` for the client, `agent` for the service.',
    )
    taskId: Optional[str] = Field(
        None,
        description='The ID of the task this message is part of. Can be omitted for the first message of a new task.',
    )


class MessageSendParams(BaseModel):
    configuration: Optional[MessageSendConfiguration] = Field(
        None, description='Optional configuration for the send request.'
    )
    message: Message = Field(
        ..., description='The message object being sent to the agent.'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata for extensions.'
    )


class OAuth2SecurityScheme(BaseModel):
    description: Optional[str] = Field(
        None, description='An optional description for the security scheme.'
    )
    flows: OAuthFlows = Field(
        ...,
        description='An object containing configuration information for the supported OAuth 2.0 flows.',
    )
    oauth2MetadataUrl: Optional[str] = Field(
        None,
        description='URL to the oauth2 authorization server metadata\n[RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.',
    )
    type: Literal['oauth2'] = Field(
        ..., description="The type of the security scheme. Must be 'oauth2'."
    )


class SecurityScheme(
    RootModel[
        Union[
            APIKeySecurityScheme,
            HTTPAuthSecurityScheme,
            OAuth2SecurityScheme,
            OpenIdConnectSecurityScheme,
            MutualTLSSecurityScheme,
        ]
    ]
):
    root: Union[
        APIKeySecurityScheme,
        HTTPAuthSecurityScheme,
        OAuth2SecurityScheme,
        OpenIdConnectSecurityScheme,
        MutualTLSSecurityScheme,
    ] = Field(
        ...,
        description="Defines a security scheme that can be used to secure an agent's endpoints.\nThis is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.",
    )


class SendMessageRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['message/send'] = Field(
        ..., description="The method name. Must be 'message/send'."
    )
    params: MessageSendParams = Field(
        ..., description='The parameters for sending a message.'
    )


class SendStreamingMessageRequest(BaseModel):
    id: Union[str, int] = Field(..., description='The identifier for this request.')
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    method: Literal['message/stream'] = Field(
        ..., description="The method name. Must be 'message/stream'."
    )
    params: MessageSendParams = Field(
        ..., description='The parameters for sending a message.'
    )


class SetTaskPushNotificationConfigResponse(
    RootModel[Union[JSONRPCErrorResponse, SetTaskPushNotificationConfigSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, SetTaskPushNotificationConfigSuccessResponse] = (
        Field(
            ...,
            description='Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set` method.',
        )
    )


class TaskArtifactUpdateEvent(BaseModel):
    append: Optional[bool] = Field(
        None,
        description='If true, the content of this artifact should be appended to a previously sent artifact with the same ID.',
    )
    artifact: Artifact = Field(
        ..., description='The artifact that was generated or updated.'
    )
    contextId: str = Field(..., description='The context ID associated with the task.')
    kind: Literal['artifact-update'] = Field(
        ...,
        description="The type of this event, used as a discriminator. Always 'artifact-update'.",
    )
    lastChunk: Optional[bool] = Field(
        None, description='If true, this is the final chunk of the artifact.'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata for extensions.'
    )
    taskId: str = Field(..., description='The ID of the task this artifact belongs to.')


class TaskStatus(BaseModel):
    message: Optional[Message] = Field(
        None,
        description='An optional, human-readable message providing more details about the current status.',
    )
    state: TaskState = Field(
        ..., description="The current state of the task's lifecycle."
    )
    timestamp: Optional[str] = Field(
        None,
        description='An ISO 8601 datetime string indicating when this status was recorded.',
        examples=['2023-10-27T10:00:00Z'],
    )


class TaskStatusUpdateEvent(BaseModel):
    contextId: str = Field(..., description='The context ID associated with the task.')
    final: bool = Field(
        ...,
        description='If true, this is the final event in the stream for this interaction.',
    )
    kind: Literal['status-update'] = Field(
        ...,
        description="The type of this event, used as a discriminator. Always 'status-update'.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Optional metadata for extensions.'
    )
    status: TaskStatus = Field(..., description='The new status of the task.')
    taskId: str = Field(..., description='The ID of the task that was updated.')


class A2ARequest(
    RootModel[
        Union[
            SendMessageRequest,
            SendStreamingMessageRequest,
            GetTaskRequest,
            CancelTaskRequest,
            SetTaskPushNotificationConfigRequest,
            GetTaskPushNotificationConfigRequest,
            TaskResubscriptionRequest,
            ListTaskPushNotificationConfigRequest,
            DeleteTaskPushNotificationConfigRequest,
            GetAuthenticatedExtendedCardRequest,
        ]
    ]
):
    root: Union[
        SendMessageRequest,
        SendStreamingMessageRequest,
        GetTaskRequest,
        CancelTaskRequest,
        SetTaskPushNotificationConfigRequest,
        GetTaskPushNotificationConfigRequest,
        TaskResubscriptionRequest,
        ListTaskPushNotificationConfigRequest,
        DeleteTaskPushNotificationConfigRequest,
        GetAuthenticatedExtendedCardRequest,
    ] = Field(
        ...,
        description='A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification.',
    )


class AgentCard(BaseModel):
    additionalInterfaces: Optional[List[AgentInterface]] = Field(
        None,
        description="A list of additional supported interfaces (transport and URL combinations).\nThis allows agents to expose multiple transports, potentially at different URLs.\n\nBest practices:\n- SHOULD include all supported transports for completeness\n- SHOULD include an entry matching the main 'url' and 'preferredTransport'\n- MAY reuse URLs if multiple transports are available at the same endpoint\n- MUST accurately declare the transport available at each URL\n\nClients can select any interface from this list based on their transport capabilities\nand preferences. This enables transport negotiation and fallback scenarios.",
    )
    capabilities: AgentCapabilities = Field(
        ...,
        description='A declaration of optional capabilities supported by the agent.',
    )
    defaultInputModes: List[str] = Field(
        ...,
        description='Default set of supported input MIME types for all skills, which can be\noverridden on a per-skill basis.',
    )
    defaultOutputModes: List[str] = Field(
        ...,
        description='Default set of supported output MIME types for all skills, which can be\noverridden on a per-skill basis.',
    )
    description: str = Field(
        ...,
        description='A human-readable description of the agent, assisting users and other agents\nin understanding its purpose.',
        examples=['Agent that helps users with recipes and cooking.'],
    )
    documentationUrl: Optional[str] = Field(
        None, description="An optional URL to the agent's documentation."
    )
    iconUrl: Optional[str] = Field(
        None, description='An optional URL to an icon for the agent.'
    )
    name: str = Field(
        ...,
        description='A human-readable name for the agent.',
        examples=['Recipe Agent'],
    )
    preferredTransport: Optional[str] = Field(
        'JSONRPC',
        description="The transport protocol for the preferred endpoint (the main 'url' field).\nIf not specified, defaults to 'JSONRPC'.\n\nIMPORTANT: The transport specified here MUST be available at the main 'url'.\nThis creates a binding between the main URL and its supported transport protocol.\nClients should prefer this transport and URL combination when both are supported.",
        examples=['JSONRPC', 'GRPC', 'HTTP+JSON'],
    )
    protocolVersion: str = Field(
        ..., description='The version of the A2A protocol this agent supports.'
    )
    provider: Optional[AgentProvider] = Field(
        None, description="Information about the agent's service provider."
    )
    security: Optional[List[Dict[str, List[str]]]] = Field(
        None,
        description='A list of security requirement objects that apply to all agent interactions. Each object\nlists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.\nThis list can be seen as an OR of ANDs. Each object in the list describes one possible\nset of security requirements that must be present on a request. This allows specifying,\nfor example, "callers must either use OAuth OR an API Key AND mTLS."',
        examples=[[{'oauth': ['read']}, {'api-key': [], 'mtls': []}]],
    )
    securitySchemes: Optional[Dict[str, SecurityScheme]] = Field(
        None,
        description='A declaration of the security schemes available to authorize requests. The key is the\nscheme name. Follows the OpenAPI 3.0 Security Scheme Object.',
    )
    signatures: Optional[List[AgentCardSignature]] = Field(
        None, description='JSON Web Signatures computed for this AgentCard.'
    )
    skills: List[AgentSkill] = Field(
        ...,
        description='The set of skills, or distinct capabilities, that the agent can perform.',
    )
    supportsAuthenticatedExtendedCard: Optional[bool] = Field(
        None,
        description='If true, the agent can provide an extended agent card with additional details\nto authenticated users. Defaults to false.',
    )
    url: str = Field(
        ...,
        description="The preferred endpoint URL for interacting with the agent.\nThis URL MUST support the transport specified by 'preferredTransport'.",
        examples=['https://api.example.com/a2a/v1'],
    )
    version: str = Field(
        ...,
        description="The agent's own version number. The format is defined by the provider.",
        examples=['1.0.0'],
    )


class GetAuthenticatedExtendedCardSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: AgentCard = Field(..., description='The result is an Agent Card object.')


class Task(BaseModel):
    artifacts: Optional[List[Artifact]] = Field(
        None,
        description='A collection of artifacts generated by the agent during the execution of the task.',
    )
    contextId: str = Field(
        ...,
        description='A server-generated unique identifier (e.g. UUID) for maintaining context across multiple related tasks or interactions.',
    )
    history: Optional[List[Message]] = Field(
        None,
        description='An array of messages exchanged during the task, representing the conversation history.',
    )
    id: str = Field(
        ...,
        description='A unique identifier (e.g. UUID) for the task, generated by the server for a new task.',
    )
    kind: Literal['task'] = Field(
        ...,
        description="The type of this object, used as a discriminator. Always 'task' for a Task.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Optional metadata for extensions. The key is an extension-specific identifier.',
    )
    status: TaskStatus = Field(
        ...,
        description='The current status of the task, including its state and a descriptive message.',
    )


class CancelTaskSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: Task = Field(
        ...,
        description='The result, containing the final state of the canceled Task object.',
    )


class GetAuthenticatedExtendedCardResponse(
    RootModel[Union[JSONRPCErrorResponse, GetAuthenticatedExtendedCardSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, GetAuthenticatedExtendedCardSuccessResponse] = (
        Field(
            ...,
            description='Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.',
        )
    )


class GetTaskSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: Task = Field(
        ..., description='The result, containing the requested Task object.'
    )


class SendMessageSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: Union[Task, Message] = Field(
        ...,
        description='The result, which can be a direct reply Message or the initial Task object.',
    )


class SendStreamingMessageSuccessResponse(BaseModel):
    id: Optional[Union[str, int]] = Field(
        ..., description='The identifier established by the client.'
    )
    jsonrpc: Literal['2.0'] = Field(
        ..., description='The version of the JSON-RPC protocol. MUST be exactly "2.0".'
    )
    result: Union[Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent] = (
        Field(
            ...,
            description='The result, which can be a Message, Task, or a streaming update event.',
        )
    )


class CancelTaskResponse(
    RootModel[Union[JSONRPCErrorResponse, CancelTaskSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, CancelTaskSuccessResponse] = Field(
        ..., description='Represents a JSON-RPC response for the `tasks/cancel` method.'
    )


class GetTaskResponse(RootModel[Union[JSONRPCErrorResponse, GetTaskSuccessResponse]]):
    root: Union[JSONRPCErrorResponse, GetTaskSuccessResponse] = Field(
        ..., description='Represents a JSON-RPC response for the `tasks/get` method.'
    )


class JSONRPCResponse(
    RootModel[
        Union[
            JSONRPCErrorResponse,
            SendMessageSuccessResponse,
            SendStreamingMessageSuccessResponse,
            GetTaskSuccessResponse,
            CancelTaskSuccessResponse,
            SetTaskPushNotificationConfigSuccessResponse,
            GetTaskPushNotificationConfigSuccessResponse,
            ListTaskPushNotificationConfigSuccessResponse,
            DeleteTaskPushNotificationConfigSuccessResponse,
            GetAuthenticatedExtendedCardSuccessResponse,
        ]
    ]
):
    root: Union[
        JSONRPCErrorResponse,
        SendMessageSuccessResponse,
        SendStreamingMessageSuccessResponse,
        GetTaskSuccessResponse,
        CancelTaskSuccessResponse,
        SetTaskPushNotificationConfigSuccessResponse,
        GetTaskPushNotificationConfigSuccessResponse,
        ListTaskPushNotificationConfigSuccessResponse,
        DeleteTaskPushNotificationConfigSuccessResponse,
        GetAuthenticatedExtendedCardSuccessResponse,
    ] = Field(
        ...,
        description='A discriminated union representing all possible JSON-RPC 2.0 responses\nfor the A2A specification methods.',
    )


class SendMessageResponse(
    RootModel[Union[JSONRPCErrorResponse, SendMessageSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, SendMessageSuccessResponse] = Field(
        ..., description='Represents a JSON-RPC response for the `message/send` method.'
    )


class SendStreamingMessageResponse(
    RootModel[Union[JSONRPCErrorResponse, SendStreamingMessageSuccessResponse]]
):
    root: Union[JSONRPCErrorResponse, SendStreamingMessageSuccessResponse] = Field(
        ...,
        description='Represents a JSON-RPC response for the `message/stream` method.',
    )
